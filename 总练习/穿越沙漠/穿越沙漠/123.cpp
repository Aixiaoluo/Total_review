//#include <stack>
//#include <iostream>
//
//using namespace std;
//
//#define  NUM 27  
//#define MAX_PATH 100  
//
//
//struct Node
//{
//	int key;
//	int flag;
//	Node()
//	{
//		flag = 0;
//	}
//};
//
//
//class Graph
//{
//public:
//	//stack<int> searchStack;  
//	int resultPath[MAX_PATH][NUM];
//	int result[NUM + 1];//将result设为NUM+1，主要是为了避免发生B->D->B的事情  
//
//	Node headNode;//起始节点  
//	Node endNode;//终止节点  
//	stack<Node> tempStack;
//	int pathNum;
//	int nPos;
//	bool Mark[NUM];
//
//public:
//	Graph()
//	{
//		//将矩阵中的元素置为空  
//		for (int i = 0; i < NUM; i++)
//		{
//			for (int j = 0; j < MAX_PATH; j++)
//			{
//				resultPath[i][j] = 0;
//			}
//			result[i] = 0;
//
//			Mark[i] = false;
//		}
//		result[NUM] = 0;
//		pathNum = 0;
//		nPos = 0;
//	}
//
//	void test()
//	{
//		//对应无向图的矩阵  
//		int Matrix[NUM][NUM] = {
//						{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
//						{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
//						{0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
//						{0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
//						{0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
//						{0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1},
//						{0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
//						{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0},
//						{0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0},
//						{1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1},
//						{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0}
//				};
//		//开始节点  
//		headNode.key = 1;
//		headNode.flag = 1;
//
//		//结束节点  
//		endNode.key = 15;
//
//		FindAllPath(Matrix, headNode, endNode);
//		cout << "顶点" << headNode.key << "到顶点" << endNode.key << "路径数目为：" << pathNum << endl;
//		for (int i = 0; i < pathNum; i++)
//		{
//			cout << "第" << i << "条: ";
//			for (int j = 0; j < NUM; j++)
//			{
//				if (resultPath[i][j] == 0)
//				{
//					break;
//				}
//				cout << resultPath[i][j] << "  ";
//			}
//			cout << endl;
//		}
//		int i = 0;
//	}
//
//
//	void FindAllPath(int Matrix[NUM][NUM], Node startNodeKey, Node endNodeKey)
//	{
//		result[nPos] = startNodeKey.key;  //将当前元素放入结果集中  
//		Mark[startNodeKey.key - 1] = true;  //将访问标记为已访问  
//		nPos++;  //结果集索引加1  
//		while (nPos != 0)
//		{
//			int tempVal = result[nPos - 1];//获取到最前面的元素    
//			if (tempVal == endNodeKey.key)  //若当前元素为目标节点  
//			{
//				for (int j = 0; j < nPos; j++)
//				{
//					resultPath[pathNum][j] = result[j];  //将结果集复制于最后的路径矩阵中  
//				}
//				nPos--;  //回溯至上一个节点  
//				result[nPos] = 0;  //结果集对应索引置为空  
//				pathNum++;  //路径数目加1  
//				Mark[endNodeKey.key - 1] = false;
//				break;
//			}
//			while (startNodeKey.flag < NUM)//利用flag来指示每次的元素的索引    
//			{
//				if (Matrix[tempVal - 1][startNodeKey.flag] == 1)
//				{
//					if (Mark[startNodeKey.flag] == false)//利用Mark来判断是否已经访问过该节点    
//					{
//						Node tempNode;
//						tempNode.key = startNodeKey.flag + 1;
//						FindAllPath(Matrix, tempNode, endNodeKey);//深度优先遍历算法，    
//					}
//				}
//				startNodeKey.flag++;//索引值相应的加一    
//			}
//
//			if (startNodeKey.flag == NUM)//如果已经是到最后的邻居，说明访问结束，    
//			{                           //将对应的值置为空    
//				nPos--;  //再次向上回溯  
//				startNodeKey.flag = 0;  //将节点的索引置为空  
//				result[nPos] = 0;  //将结果集中对应的索引置为空  
//				Mark[startNodeKey.key - 1] = false;  //访问之后标记为未访问。因为下面的元素已经访问结束，便于下次的访问  
//				break;
//			}
//		}
//	}
//};
//
//int main()
//{
//	Graph G;
//	G.test();
//	return 0;
//}